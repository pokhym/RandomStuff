load abp.maude
load ~/soft/maude/rltool/rltool.maude
--- set print attribute on .
set show advisories off .

--- set break on .
--- break select init' .

***(
	prove one rule at a time by commenting out the other rules in the specification

	after select module but before declare vars select rule
)

(select ABP .)
(use tool conrew for validity on ABP with FOFORMSIMPLIFY .)
(use tool conrew for unsatisfiability on ABP .)

--- (select-rls label1 label2 .)
(select-rls send-1 .)

--- it appears that var sat requires no subsumes??????????
--- (use tool varsat for validity on ABP .)

(declare-vars (S1:Sys) U (S2:Sys) 
	U (N1:iNat) U (B1:Bit) U (BPQ1:BitPacketQueue) U (BQ1:BitQueue) U (B1':Bit) U (NL1:iNatList)
	U (N2:iNat) U (B2:Bit) U (BPQ2:BitPacketQueue) U (BQ2:BitQueue) U (B2':Bit) U (NL2:iNatList)
.)

--- term set are states satisfy inv and are []
(
	def-term-set 
		([N1 : B1 > BPQ1 | BQ1 < B1' : NL1]) 
			| ((gen-list(N1) ~iNL (NL1)) = (true) /\ (B1 ~B B1') = (false)) \/ ((gen-list(N1) ~iNL (N1 NL1)) = (true) /\ (B1 ~B B1') = (true))
.)

(inv invmainI to '`[_:_>_|_<_:_`] on ( (N1 : B1 > BPQ1 | BQ1 < B1' : NL1) | ((gen-list(N1) ~iNL (NL1)) = (true) /\ (B1 ~B B1') = (false)) ) 
	   \/ ( (N1 : B1 > BPQ1 | BQ1 < B1' : NL1) | ((gen-list(N1) ~iNL (N1 NL1)) = (true)) ) 
.)


(start-proof .)

(case (N3:iNat : B4:Bit > BPQ5:BitPacketQueue | BQ6:BitQueue < B8:Bit : INL9:NeiNatList) on N3:iNat by (0:iNat) U (s N10:iNat) .)
(case (N3:iNat : B4:Bit > BPQ5:BitPacketQueue | BQ6:BitQueue < B8:Bit : INL9:iNatList) on INL9:iNatList by (nil:iNatList) U (INL10:NeiNatList) .)

(auto .)
(auto .)
quit